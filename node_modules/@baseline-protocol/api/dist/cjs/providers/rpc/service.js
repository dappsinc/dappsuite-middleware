"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rpc = void 0;
const axios_1 = __importDefault(require("axios"));
const defaultJsonRpcUrl = 'http://localhost:8545';
const defaultJsonRpcVersion = '2.0';
class Rpc {
    constructor(config) {
        this.config = config;
        this.id = 1;
        this.version = config ? config.rpcVersion : defaultJsonRpcVersion;
        this.url = config ? `${config.rpcScheme}://${config.rpcEndpoint}` : defaultJsonRpcUrl;
    }
    call(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield axios_1.default.post(this.url, {
                id: this.id++,
                method: method,
                params: params,
                version: this.version,
            });
            const data = resp ? resp.data : null;
            if (data && typeof data.result !== 'undefined' && typeof data.error === 'undefined') {
                return data.result;
            }
            else if (data && typeof data.error !== 'undefined') {
                return Promise.reject(data.error);
            }
            else if (data) {
                return data;
            }
            return Promise.reject('failed to receive json-rpc response');
        });
    }
    deploy(sender, bytecode, abi) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_deploy', [sender, bytecode, abi]);
        });
    }
    getLeaf(address, index) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_getLeaf', [address, index]);
        });
    }
    getLeaves(address, indexes) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_getLeaves', [address, indexes]);
        });
    }
    getRoot(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_getRoot', [address]);
        });
    }
    getSiblings(address, leafIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_getSiblings', [address, leafIndex]);
        });
    }
    getTracked() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_getTracked', []);
        });
    }
    insertLeaf(sender, address, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_insertLeaf', [sender, address, value]);
        });
    }
    insertLeaves(sender, address, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_insertLeaves', [sender, address, value]);
        });
    }
    track(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_track', [address]);
        });
    }
    verify(address, root, leaf, siblingPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('baseline_verify', [address, root, leaf, siblingPath]);
        });
    }
    broadcast(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.call('eth_sendRawTransaction', [tx]);
        });
    }
    fetchTxReceipt(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.call('eth_getTransactionReceipt', [hash]);
        });
    }
    exec(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.call(method, params);
        });
    }
    generateKeypair() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.reject('generateKeypair() not yet implemented');
        });
    }
    rpcExec(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.exec(method, params);
        });
    }
    sign(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.call('eth_signTransaction', [params]);
        });
    }
    createWorkgroup(params) {
        throw new Error('not implemented');
    }
    updateWorkgroup(workgroupId, params) {
        throw new Error('not implemented');
    }
    fetchWorkgroups(params) {
        throw new Error('not implemented');
    }
    fetchWorkgroupDetails(workgroupId) {
        throw new Error('not implemented');
    }
    fetchWorkgroupOrganizations(workgroupId, params) {
        throw new Error('not implemented');
    }
    createWorkgroupOrganization(workgroupId, params) {
        throw new Error('not implemented');
    }
    updateWorkgroupOrganization(workgroupId, organizationId, params) {
        throw new Error('not implemented');
    }
    fetchWorkgroupInvitations(workgroupId, params) {
        throw new Error('not implemented');
    }
    fetchWorkgroupUsers(workgroupId, params) {
        throw new Error('not implemented');
    }
    createWorkgroupUser(workgroupId, params) {
        throw new Error('not implemented');
    }
    updateWorkgroupUser(workgroupId, userId, params) {
        throw new Error('not implemented');
    }
    deleteWorkgroupUser(workgroupId, userId) {
        throw new Error('not implemented');
    }
    createOrganization(params) {
        throw new Error('not implemented');
    }
    fetchOrganizations(params) {
        throw new Error('not implemented');
    }
    fetchOrganizationDetails(organizationId) {
        throw new Error('not implemented');
    }
    updateOrganization(organizationId, params) {
        throw new Error('not implemented');
    }
    fetchOrganizationInvitations(organizationId, params) {
        throw new Error('not implemented');
    }
    fetchOrganizationUsers(organizationId, params) {
        throw new Error('not implemented');
    }
    inviteOrganizationUser(organizationId, params) {
        throw new Error('not implemented');
    }
    createVault(params) {
        throw new Error('not implemented');
    }
    fetchVaults(params) {
        throw new Error('not implemented');
    }
    fetchVaultKeys(vaultId, params) {
        throw new Error('not implemented');
    }
    createVaultKey(vaultId, params) {
        throw new Error('not implemented');
    }
    deleteVaultKey(vaultId, keyId) {
        throw new Error('not implemented');
    }
    encrypt(vaultId, keyId, payload) {
        throw new Error('not implemented');
    }
    decrypt(vaultId, keyId, payload) {
        throw new Error('not implemented');
    }
    signMessage(vaultId, keyId, msg) {
        throw new Error('not implemented');
    }
    verifySignature(vaultId, keyId, msg, sig) {
        throw new Error('not implemented');
    }
    fetchVaultSecrets(vaultId, params) {
        throw new Error('not implemented');
    }
    createVaultSecret(vaultId, params) {
        throw new Error('not implemented');
    }
    deleteVaultSecret(vaultId, secretId) {
        throw new Error('not implemented');
    }
}
exports.Rpc = Rpc;
//# sourceMappingURL=service.js.map