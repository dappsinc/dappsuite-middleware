"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhisperService = void 0;
const winston_1 = __importDefault(require("winston"));
const web3Utils_1 = require("./web3Utils");
const DEFAULT_CONNECTED_INTERVAL = 2000;
const DEFAULT_TOPIC = process.env.WHISPER_TOPIC || '0x11223344';
const POW_TIME = process.env.WHISPER_POW_TIME || 100;
const TTL = process.env.WHISPER_TTL || 20;
const POW_TARGET = process.env.WHISPER_POW_TARGET || 2;
class WhisperService {
    constructor(config) {
        this.keyId = config.keyId;
        this.clientUrl = config.clientUrl;
        this.web3Connected = false;
        this.initConnectedInterval();
    }
    initConnectedInterval() {
        this.web3Connected = false;
        if (this.connectedInterval) {
            this.stopConnectedInterval();
        }
        this.connectedInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            this.web3Connected = yield web3Utils_1.isWeb3Connected();
        }), DEFAULT_CONNECTED_INTERVAL);
    }
    stopConnectedInterval() {
        if (this.connectedInterval) {
            clearInterval(this.connectedInterval);
            this.connectedInterval = null;
        }
        this.web3Connected = false;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            return web3Utils_1.getWeb3(this.clientUrl);
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isConnected()) {
                this.stopConnectedInterval();
            }
            return Promise.resolve();
        });
    }
    isConnected() {
        return this.web3Connected;
    }
    publish(subject = DEFAULT_TOPIC, payload, reply, recipientId, senderId) {
        return __awaiter(this, void 0, void 0, function* () {
            let messageString = payload;
            if (typeof payload === 'object') {
                messageString = JSON.stringify(payload);
            }
            const web3 = yield web3Utils_1.getWeb3(this.clientUrl);
            const content = web3.utils.fromAscii(messageString);
            let keyId = this.keyId;
            if (senderId) {
                keyId = senderId;
            }
            try {
                const messageObj = {
                    pubKey: recipientId,
                    sig: keyId,
                    ttl: TTL,
                    topic: subject,
                    payload: content,
                    powTime: POW_TIME,
                    powTarget: POW_TARGET,
                };
                const hash = yield web3.shh.post(messageObj);
                const time = Math.floor(Date.now() / 1000);
                const publicKey = yield web3.shh.getPublicKey(keyId);
                return {
                    payload: messageString,
                    _id: hash,
                    hash,
                    recipientPublicKey: recipientId,
                    sig: publicKey,
                    ttl: messageObj.ttl,
                    topic: messageObj.topic,
                    pow: POW_TARGET,
                    timestamp: time
                };
            }
            catch (err) {
                winston_1.default.error('Whisper publish error:', err);
            }
        });
    }
    subscribe(subject = DEFAULT_TOPIC, callback, myId) {
        return __awaiter(this, void 0, void 0, function* () {
            const web3 = yield web3Utils_1.getWeb3(this.clientUrl);
            return web3.shh
                .subscribe('messages', {
                minPow: POW_TARGET,
                privateKeyID: myId,
                topics: [subject],
            })
                .on('data', (data) => __awaiter(this, void 0, void 0, function* () {
                try {
                    callback.call(this, data);
                }
                catch (error) {
                    winston_1.default.error(error.message);
                }
            }))
                .on('error', (err) => {
                winston_1.default.error(err);
            });
        });
    }
    loadIdentities(identities, topic = DEFAULT_TOPIC, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const loadedIds = yield new Array();
            if (identities.length === 0) {
                const newId = yield this.createIdentity(topic, callback);
                loadedIds.push(newId);
            }
            else {
                const web3 = yield web3Utils_1.getWeb3(this.clientUrl);
                yield Promise.all(identities.map((id) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const keyId = yield web3.shh.addPrivateKey(id.privateKey);
                        const publicKey = yield web3.shh.getPublicKey(keyId);
                        loadedIds.push({ publicKey, keyId });
                        yield this.subscribe(topic, callback, keyId);
                    }
                    catch (err) {
                        winston_1.default.error(`Error adding public key ${id.publicKey} to Whisper node: ${err}`);
                    }
                })));
            }
            ;
            this.keyId = loadedIds[0]['keyId'];
            return loadedIds;
        });
    }
    createIdentity(topic = DEFAULT_TOPIC, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const web3 = yield web3Utils_1.getWeb3(this.clientUrl);
            const keyId = yield web3.shh.newKeyPair();
            const publicKey = yield web3.shh.getPublicKey(keyId);
            const privateKey = yield web3.shh.getPrivateKey(keyId);
            const createdDate = yield Math.floor(Date.now() / 1000);
            yield this.subscribe(topic, callback, keyId);
            this.keyId = keyId;
            return { publicKey, privateKey, keyId, createdDate };
        });
    }
}
exports.WhisperService = WhisperService;
//# sourceMappingURL=whisper.js.map