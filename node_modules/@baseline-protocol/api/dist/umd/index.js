!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports["@baseline-protocol/api"]=t():e["@baseline-protocol/api"]=t()}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=2)}([function(e,t){e.exports=require("provide-js")},function(e,t){e.exports=require("axios")},function(e,t,r){"use strict";r.r(t),r.d(t,"baselineProviderEthers",(function(){return p})),r.d(t,"baselineProviderProvide",(function(){return u})),r.d(t,"baselineProviderRpc",(function(){return h})),r.d(t,"MerkleTreeNode",(function(){return l})),r.d(t,"baselineServiceFactory",(function(){return d}));class n{constructor(e){this.config=e}async fetchTxReceipt(e){throw new Error("not implemented")}async generateKeypair(){throw new Error("not implemented")}async broadcast(e){throw new Error("not implemented")}async rpcExec(e,t){throw new Error("not implemented")}async sign(e){throw new Error("not implemented")}createWorkgroup(e){throw new Error("not implemented")}updateWorkgroup(e,t){throw new Error("not implemented")}fetchWorkgroups(e){throw new Error("not implemented")}fetchWorkgroupDetails(e){throw new Error("not implemented")}fetchWorkgroupOrganizations(e,t){throw new Error("not implemented")}createWorkgroupOrganization(e,t){throw new Error("not implemented")}updateWorkgroupOrganization(e,t,r){throw new Error("not implemented")}fetchWorkgroupInvitations(e,t){throw new Error("not implemented")}fetchWorkgroupTokens(e){throw new Error("not implemented")}fetchWorkgroupUsers(e,t){throw new Error("not implemented")}createWorkgroupUser(e,t){throw new Error("not implemented")}updateWorkgroupUser(e,t,r){throw new Error("not implemented")}deleteWorkgroupUser(e,t){throw new Error("not implemented")}createOrganization(e){throw new Error("not implemented")}fetchOrganizations(e){throw new Error("not implemented")}fetchOrganizationDetails(e){throw new Error("not implemented")}updateOrganization(e,t){throw new Error("not implemented")}fetchOrganizationInvitations(e,t){throw new Error("not implemented")}fetchOrganizationUsers(e,t){throw new Error("not implemented")}inviteOrganizationUser(e,t){throw new Error("not implemented")}createVault(e){throw new Error("not implemented")}fetchVaults(e){throw new Error("not implemented")}fetchVaultKeys(e,t){throw new Error("not implemented")}createVaultKey(e,t){throw new Error("not implemented")}deleteVaultKey(e,t){throw new Error("not implemented")}encrypt(e,t,r){throw new Error("not implemented")}decrypt(e,t,r){throw new Error("not implemented")}signMessage(e,t,r){throw new Error("not implemented")}verifySignature(e,t,r,n){throw new Error("not implemented")}fetchVaultSecrets(e,t){throw new Error("not implemented")}createVaultSecret(e,t){throw new Error("not implemented")}deleteVaultSecret(e,t){throw new Error("not implemented")}}var o=r(0);class i{constructor(e){this.config=e,e&&e.token&&(this.ident=o.Ident.clientFactory(e.token,e.identApiScheme,e.identApiHost),this.vault=o.Vault.clientFactory(e.token,e.vaultApiScheme,e.vaultApiHost)),this.rpc=new o.RpcClient(null==e?void 0:e.rpcScheme,null==e?void 0:e.rpcEndpoint)}async deploy(e,t,r){return await this.rpc.call("baseline_deploy",[e,t,r])}async getLeaf(e,t){return await this.rpc.call("baseline_getLeaf",[e,t])}async getLeaves(e,t){return await this.rpc.call("baseline_getLeaves",[e,t])}async getRoot(e){return await this.rpc.call("baseline_getRoot",[e])}async getSiblings(e,t){return await this.rpc.call("baseline_getSiblings",[e,t])}async getTracked(){return await this.rpc.call("baseline_getTracked",[])}async insertLeaf(e,t,r){return await this.rpc.call("baseline_insertLeaf",[e,t,r])}async insertLeaves(e,t,r){return await this.rpc.call("baseline_insertLeaves",[e,t,r])}async track(e){return await this.rpc.call("baseline_track",[e])}async verify(e,t,r,n){return await this.rpc.call("baseline_verify",[e,t,r,n])}async broadcast(e){return this.rpc.call("eth_sendRawTransaction",[e])}async fetchTxReceipt(e){return this.rpc.call("eth_getTransactionReceipt",[e])}async generateKeypair(){return Promise.reject("generateKeypair() not yet implemented")}async rpcExec(e,t){return this.rpc.call(e,t)}async sign(e){return this.rpc.call("eth_signTransaction",[e])}createWorkgroup(e){return this.ident.createApplication(e)}updateWorkgroup(e,t){return this.ident.updateApplication(e,t)}fetchWorkgroups(e){return this.ident.fetchApplications(e)}fetchWorkgroupDetails(e){return this.ident.fetchApplicationDetails(e)}fetchWorkgroupOrganizations(e,t){return this.ident.fetchApplicationOrganizations(e,t)}createWorkgroupOrganization(e,t){return this.ident.createApplicationOrganization(e,t)}updateWorkgroupOrganization(e,t,r){return this.ident.updateApplicationOrganization(e,t,r)}fetchWorkgroupInvitations(e,t){return this.ident.fetchApplicationInvitations(e,t)}fetchWorkgroupTokens(e){return this.ident.fetchApplicationTokens(e)}fetchWorkgroupUsers(e,t){return this.ident.fetchApplicationUsers(e,t)}createWorkgroupUser(e,t){return this.ident.createApplicationUser(e,t)}updateWorkgroupUser(e,t,r){return this.ident.updateApplicationUser(e,t,r)}deleteWorkgroupUser(e,t){return this.ident.deleteApplicationUser(e,t)}createOrganization(e){return this.ident.createOrganization(e)}fetchOrganizations(e){return this.ident.fetchOrganizations(e)}fetchOrganizationDetails(e){return this.ident.fetchOrganizationDetails(e)}updateOrganization(e,t){return this.ident.updateOrganization(e,t)}fetchOrganizationInvitations(e,t){return this.ident.fetchOrganizationInvitations(e,t)}fetchOrganizationUsers(e,t){return this.ident.fetchOrganizationUsers(e,t)}inviteOrganizationUser(e,t){return this.ident.createOrganizationUser(e,t)}createVault(e){return this.vault.createVault(e)}fetchVaults(e){return this.vault.fetchVaults(e)}fetchVaultKeys(e,t){return this.vault.fetchVaultKeys(e,t)}createVaultKey(e,t){return this.vault.createVaultKey(e,t)}deleteVaultKey(e,t){return this.vault.deleteVaultKey(e,t)}encrypt(e,t,r){return this.vault.encrypt(e,t,r)}decrypt(e,t,r){return this.vault.decrypt(e,t,r)}signMessage(e,t,r){return this.vault.signMessage(e,t,r)}verifySignature(e,t,r,n){return this.vault.verifySignature(e,t,r,n)}fetchVaultSecrets(e,t){return this.vault.fetchVaultSecrets(e,t)}createVaultSecret(e,t){return this.vault.createVaultSecret(e,t)}deleteVaultSecret(e,t){return this.vault.deleteVaultSecret(e,t)}}var a=r(1),s=r.n(a);class c{constructor(e){this.config=e,this.id=1,this.version=e?e.rpcVersion:"2.0",this.url=e?`${e.rpcScheme}://${e.rpcEndpoint}`:"http://localhost:8545"}async call(e,t){const r=await s.a.post(this.url,{id:this.id++,method:e,params:t,version:this.version}),n=r?r.data:null;return n&&void 0!==n.result&&void 0===n.error?n.result:n&&void 0!==n.error?Promise.reject(n.error):n||Promise.reject("failed to receive json-rpc response")}async deploy(e,t,r){return await this.call("baseline_deploy",[e,t,r])}async getLeaf(e,t){return await this.call("baseline_getLeaf",[e,t])}async getLeaves(e,t){return await this.call("baseline_getLeaves",[e,t])}async getRoot(e){return await this.call("baseline_getRoot",[e])}async getSiblings(e,t){return await this.call("baseline_getSiblings",[e,t])}async getTracked(){return await this.call("baseline_getTracked",[])}async insertLeaf(e,t,r){return await this.call("baseline_insertLeaf",[e,t,r])}async insertLeaves(e,t,r){return await this.call("baseline_insertLeaves",[e,t,r])}async track(e){return await this.call("baseline_track",[e])}async verify(e,t,r,n){return await this.call("baseline_verify",[e,t,r,n])}async broadcast(e){return this.call("eth_sendRawTransaction",[e])}async fetchTxReceipt(e){return this.call("eth_getTransactionReceipt",[e])}async exec(e,t){return this.call(e,t)}async generateKeypair(){return Promise.reject("generateKeypair() not yet implemented")}async rpcExec(e,t){return this.exec(e,t)}async sign(e){return this.call("eth_signTransaction",[e])}createWorkgroup(e){throw new Error("not implemented")}updateWorkgroup(e,t){throw new Error("not implemented")}fetchWorkgroups(e){throw new Error("not implemented")}fetchWorkgroupDetails(e){throw new Error("not implemented")}fetchWorkgroupOrganizations(e,t){throw new Error("not implemented")}createWorkgroupOrganization(e,t){throw new Error("not implemented")}updateWorkgroupOrganization(e,t,r){throw new Error("not implemented")}fetchWorkgroupInvitations(e,t){throw new Error("not implemented")}fetchWorkgroupTokens(e){throw new Error("not implemented")}fetchWorkgroupUsers(e,t){throw new Error("not implemented")}createWorkgroupUser(e,t){throw new Error("not implemented")}updateWorkgroupUser(e,t,r){throw new Error("not implemented")}deleteWorkgroupUser(e,t){throw new Error("not implemented")}createOrganization(e){throw new Error("not implemented")}fetchOrganizations(e){throw new Error("not implemented")}fetchOrganizationDetails(e){throw new Error("not implemented")}updateOrganization(e,t){throw new Error("not implemented")}fetchOrganizationInvitations(e,t){throw new Error("not implemented")}fetchOrganizationUsers(e,t){throw new Error("not implemented")}inviteOrganizationUser(e,t){throw new Error("not implemented")}createVault(e){throw new Error("not implemented")}fetchVaults(e){throw new Error("not implemented")}fetchVaultKeys(e,t){throw new Error("not implemented")}createVaultKey(e,t){throw new Error("not implemented")}deleteVaultKey(e,t){throw new Error("not implemented")}encrypt(e,t,r){throw new Error("not implemented")}decrypt(e,t,r){throw new Error("not implemented")}signMessage(e,t,r){throw new Error("not implemented")}verifySignature(e,t,r,n){throw new Error("not implemented")}fetchVaultSecrets(e,t){throw new Error("not implemented")}createVaultSecret(e,t){throw new Error("not implemented")}deleteVaultSecret(e,t){throw new Error("not implemented")}}class l{constructor(e,t){this.hash=e,this.index=t}}const p="ethers",u="provide",h="rpc";async function d(e,t){let r;switch(e){case p:r=new n(t);break;case u:r=new i(t);break;case h:r=new c(t);break;default:throw new Error("blockchain service provider required")}return r}}])}));