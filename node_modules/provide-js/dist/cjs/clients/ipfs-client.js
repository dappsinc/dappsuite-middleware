"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IpfsClient = void 0;
const ipfs_http_client_1 = __importDefault(require("ipfs-http-client"));
const mime_types_1 = require("mime-types");
const api_client_1 = require("./api-client");
class IpfsClient {
    constructor(scheme = IpfsClient.DEFAULT_SCHEME, host = IpfsClient.DEFAULT_HOST, port = IpfsClient.DEFAULT_PORT, path = IpfsClient.DEFAULT_PATH) {
        this.apiClient = new api_client_1.ApiClient(undefined, scheme, host, path);
        let sanitizedHost = host;
        const portSuffix = `:${port}`;
        if (host.lastIndexOf(portSuffix) === host.length - portSuffix.length) {
            sanitizedHost = host.substr(0, host.length - portSuffix.length);
        }
        this.ipfs = new ipfs_http_client_1.default({
            protocol: scheme,
            host: sanitizedHost,
            port: port,
            'api-path': path,
        });
    }
    add(path, content, options = null) {
        const files = [{
                path: path,
                content: content,
            }];
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const retvals = [];
            const gen = this.ipfs.add(files, options);
            let result = yield gen.next();
            if (!result) {
                reject(`failed to add ${content.byteLength}-byte object to IPFS`);
                return;
            }
            if (result && typeof result.value !== 'undefined') {
                retvals.push(result.value);
            }
            while (!result.done) {
                result = yield gen.next();
                if (result && typeof result.value !== 'undefined') {
                    retvals.push(result.value);
                }
            }
            resolve(retvals);
        }));
    }
    cat(hash) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let retval;
            const gen = this.ipfs.cat(hash);
            let result = yield gen.next();
            if (!result) {
                reject(`failed to cat IPFS object: ${hash}`);
                return;
            }
            retval = result.value;
            while (!result.done) {
                result = yield gen.next();
            }
            resolve(retval);
        }));
    }
    ls(hashes) {
        return new Promise((resolve, reject) => {
            this.apiClient.get('ls', { arg: hashes }).then((response) => {
                const links = [];
                response.data['Objects'].forEach((ipfsObject) => {
                    ipfsObject['Links'].forEach((lnk) => {
                        links.push({
                            hash: lnk['Hash'],
                            mime: lnk['Name'] === '' ? null : mime_types_1.lookup(lnk['Name']),
                            name: lnk['Name'],
                            size: lnk['Size'],
                            target: lnk['Target'] === '' ? null : lnk['Target'],
                            type: lnk['Type'],
                        });
                    });
                });
                resolve(links);
            }).catch((error) => {
                reject(error);
            });
        });
    }
}
exports.IpfsClient = IpfsClient;
IpfsClient.DEFAULT_SCHEME = 'http';
IpfsClient.DEFAULT_HOST = 'ipfs.provide.services';
IpfsClient.DEFAULT_PORT = 5001;
IpfsClient.DEFAULT_PATH = '/api/v0/';
IpfsClient.DEFAULT_GATEWAY_PORT = 8080;
IpfsClient.DEFAULT_GATEWAY_PATH = '/ipfs/';
//# sourceMappingURL=ipfs-client.js.map