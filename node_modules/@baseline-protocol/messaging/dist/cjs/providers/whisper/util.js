"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const axios = require('axios');
const logger = require('winston');
require('../../../../../../messenger-tmp/src/logger');
const Identity = require('../../../../../../messenger-tmp/src/db/models/Identity');
const Message = require('../../../../../../messenger-tmp/src/db/models/Message');
const { receiveMessageQueue } = require('../../../../../../messenger-tmp/src/queues/receiveMessage');
const { DEFAULT_TOPIC, POW_TIME, TTL, POW_TARGET, } = require('../clients/whisper/whisperUtils.js');
const radishApiUrl = process.env.RADISH_API_URL ? `${process.env.RADISH_API_URL}/api/v1` : 'http://localhost:8101/api/v1';
function hasJsonStructure(str) {
    if (typeof str !== 'string') {
        return false;
    }
    try {
        const result = JSON.parse(str);
        const type = Object.prototype.toString.call(result);
        const isJSON = type === '[object Object]' || type === '[object Array]';
        return [isJSON, result];
    }
    catch (err) {
        return [false, {}];
    }
}
function safeJsonParse(str) {
    try {
        return [null, JSON.parse(str)];
    }
    catch (err) {
        return [err];
    }
}
function getIdentities() {
    return __awaiter(this, void 0, void 0, function* () {
        const identities = yield Identity.find({}, '-_id publicKey createdDate').lean();
        return identities;
    });
}
function findIdentity(myId) {
    return __awaiter(this, void 0, void 0, function* () {
        return Identity.exists({ _id: myId });
    });
}
function getMessages(myId, topic = DEFAULT_TOPIC, partnerId, since) {
    return __awaiter(this, void 0, void 0, function* () {
        const currentTime = Math.floor(Date.now() / 1000);
        let timeThreshold = parseInt(since, 10);
        if (!since) {
            timeThreshold = currentTime - 86400;
        }
        if (!partnerId) {
            const messages = yield Message.aggregate([
                {
                    $match: {
                        topic,
                        sentDate: { $gte: timeThreshold },
                        $or: [{ recipientId: myId }, { senderId: myId }],
                    },
                },
            ]);
            return messages;
        }
        return Message.aggregate([
            {
                $match: {
                    topic,
                    sentDate: { $gte: timeThreshold },
                    $or: [
                        { topic, recipientId: myId, senderId: partnerId },
                        { topic, recipientId: partnerId, senderId: myId },
                    ],
                },
            },
        ]);
    });
}
function getSingleMessage(messageId) {
    return __awaiter(this, void 0, void 0, function* () {
        return Message.findOne({ _id: messageId });
    });
}
function storeNewMessage(messageData, payloadAscii) {
    return __awaiter(this, void 0, void 0, function* () {
        const { hash, recipientPublicKey, sig, ttl, topic, pow, timestamp } = messageData;
        return Message.findOneAndUpdate({ _id: hash }, {
            _id: hash,
            messageType: 'individual',
            recipientId: recipientPublicKey,
            senderId: sig,
            ttl,
            topic,
            payload: payloadAscii,
            pow,
            sentDate: timestamp,
        }, { upsert: true, new: true });
    });
}
function forwardMessage(messageObj) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.info(`Forwarding message to api microservice: POST ${radishApiUrl}/documents.`, { service: 'MESSENGER' });
        try {
            const response = yield axios.post(`${radishApiUrl}/documents`, messageObj);
            logger.http('Success', { service: 'MESSENGER', statusCode: response.status, responseData: response.data, requestMethod: 'POST', requestUrl: `${radishApiUrl}/documents` });
        }
        catch (err) {
            logger.error(`POST ${radishApiUrl}/documents failed.\n%o`, err, { service: 'MESSENGER' });
            if (err.response) {
                logger.error(`${err.response.status} - %o`, err.response.data, { service: 'MESSENGER' });
            }
        }
    });
}
module.exports = {
    hasJsonStructure,
    safeJsonParse,
    getIdentities,
    findIdentity,
    getMessages,
    getSingleMessage,
    storeNewMessage,
    forwardMessage,
    DEFAULT_TOPIC,
    POW_TIME,
    TTL,
    POW_TARGET,
};
//# sourceMappingURL=util.js.map